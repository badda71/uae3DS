#include "sysconfig.h"

#ifndef NO_MENU
#ifndef NO_SAVE_MENU

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <SDL/SDL_image.h>
#include <SDL/SDL_rotozoom.h>

#include "menu.h"
#include "sysdeps.h"
#include "config.h"
#include "uae.h"
#include "options.h"
#include "sound.h"
#include "savestate.h"
#include "keyboard.h"
#include "uibottom.h"
#include "uae3ds.h"

typedef struct {
	char *name;
	int snaps;
} ASFFile;

#define NUM_SS 4

static ASFFile (*files)[] = NULL;
static int nrfiles = 0;
static int offset = 0;
const int lines = 3;
const int height = 26;
const int width = 46;
static SDL_Surface *thumbs[lines * NUM_SS] = {0};

static char *text_str_title;
static const char *text_str_title1="Load State";
static const char *text_str_title2="Save State";
//static const char *text_str_savestate="Saved state #";
//static const char *text_str_0="0";
//static const char *text_str_1="1";
//static const char *text_str_2="2";
//static const char *text_str_3="3";
//static const char *text_str_loadmem="Load state (Y)";
//static const char *text_str_savemem="Save state (X)";
//static const char *text_str_separator="----------------------------------------------";
//static const char *text_str_exit="Main menu (B)";

extern SDL_Surface *text_screen;
extern Uint32 menu_inv_color;

int saveMenu_n_savestate=0;
int saveMenu_n_savestate_real=0;
int saveMenu_case=-1;

static SaveMode mode = MODE_LOAD;

enum { 
	SAVE_MENU_CASE_EXIT,
	SAVE_MENU_CASE_LOAD_MEM,
	SAVE_MENU_CASE_SAVE_MEM,
	SAVE_MENU_CASE_DEL_MEM,
	SAVE_MENU_CASE_CANCEL };

static u8 noimg[]={
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01
};

static SDL_Surface *getThumb(char *ssname, int idx)
{
	SDL_Surface *s, *r;
	char *tname = (char*)malloc(strlen(SAVESTATE_PREFIX) + strlen(ssname) + 7);
	sprintf(tname, "%s%s-%d.png",SAVESTATE_PREFIX,ssname,idx%10);
	s = IMG_Load(tname);
	if (s) {
		r = shrinkSurface(s, 4, 4);
	} else {
		s = SDL_CreateRGBSurfaceFrom(noimg, 32, 28, 8, 32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000);
		SDL_Color colors[2] = {{0x30,0x30,0x30,0},{0xff,0x00,0x00,0}};
		SDL_SetPalette(s,SDL_LOGPAL|SDL_PHYSPAL, colors, 0, 2);
		SDL_SetColorKey(s, SDL_SRCCOLORKEY, SDL_MapRGB( s->format, 0xff, 0x00, 0x00 ));
		r = SDL_CreateRGBSurface(SDL_SWSURFACE, 80, 60, 32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000);
		SDL_FillRect(r,NULL,SDL_MapRGB(r->format, 0xce, 0xcf, 0xce));
		SDL_BlitSurface(s,NULL, r, &(SDL_Rect){24,16,0,0});
	}
	SDL_FreeSurface(s);
	free(tname);
	return r;
}

static void adjustSavestate(int c) {
	int d=0;
	while (
		(saveMenu_n_savestate < 0 ||
		saveMenu_n_savestate >= NUM_SS ||
		((*files)[c].snaps & (1 << saveMenu_n_savestate)) == 0) &&
		abs(d) < NUM_SS)
	{
		d=(-1*d)+(d>0?-1:1);
		saveMenu_n_savestate += d;
	}
}

static inline void draw_saveMenu(int c)
{
	static int b=0;
	int bb=(b%6)/3;
	int i,x;
	static int old_c=c, old_offset=offset;
	static Scrollstatus ss = {0};
	int row = 15*8-height*4-4, col = 25*8-width*4;
	char buf[3];
	strcpy(buf,"#x");

	if (old_c != c) {
		memset(&ss, 0, sizeof(ss));
		old_c = c;
	}

	text_draw_background();
	text_draw_window(192-width*4, 112-height*4, (width+2)*8, (height+2)*8, text_str_title);

	// adjust c, offset & savestate if needed
	if (c<0) c==0;
	if (c>=nrfiles) c=nrfiles-1;
	if (c >= offset + lines) offset = c+1-lines;
	if (c < offset) offset = c;
	if (mode==MODE_LOAD) adjustSavestate(c);

	// adjust thumbnail positions
	if (old_offset != offset) {
		int shft = (offset - old_offset) * NUM_SS;
		i = shft > 0 ? 0 : lines*NUM_SS-1;
		while (i >= 0 && i < lines * NUM_SS) {
			if (i-shft < 0 || i-shft >= lines * NUM_SS) {
				SDL_FreeSurface(thumbs[i]);
				thumbs[i] = NULL;
			}
			if (i+shft >= 0 && i+shft < lines * NUM_SS) {
				thumbs[i] = thumbs[i+shft];
			} else {
				thumbs[i] = NULL;
			}
			shft > 0 ? ++i : --i;
		}
		old_offset = offset;
	}

	if (nrfiles > lines) {
		draw_scrollbar(col + width * 8 + 2, row - 2, 6, lines * 73, nrfiles, lines, offset);
	}
	char text[width+1];

	for (i = offset; i < nrfiles && i < offset + lines; ++i) {
		if (c==i) {
			write_text_pos_scroll(&ss, 1, 1, col, row, width, (*files)[i].name);
		} else {
			snprintf(text,width+1,"%s",(*files)[i].name);
			write_text_pos(col, row, text);
		}

		row+=10;
		for(x=0; x<NUM_SS; ++x) {
			if ((*files)[i].snaps & (1<<x)) {
				int t=(i-offset)*NUM_SS+x;
				if (thumbs[t] == NULL)
					thumbs[t] = getThumb((*files)[i].name, x);
				SDL_BlitSurface(thumbs[t], NULL, text_screen, &(SDL_Rect){(Sint16)(col+5+x*90), (Sint16)row, 0, 0});
			} else {
				SDL_FillRect(text_screen, &(SDL_Rect){(Sint16)(col+5+x*90), (Sint16)row, 80, 60}, menu_inv2_color);
			}
			Uint32 back1, back2;
			buf[1]=x+'1';
			if (!((*files)[i].snaps & (1<<x))) {
				back1 = menu_text_color;
				menu_text_color = menu_text_color_inactive;
			}
			if (saveMenu_n_savestate==x && c==i && bb)
				write_text_inv_pos(col+7+x*90,row+2,buf);
			else {
				back2 = menu_inv_color;
				menu_inv_color = menu_inv2_color;
				write_text_inv_pos(col+7+x*90,row+2,buf);
				menu_inv_color = back2;
			}
			if (!((*files)[i].snaps & (1<<x))) {
				menu_text_color = back1;
			}
		}
		row+=63;
	}

	text_flip();
	b++;
}

static inline int key_saveMenu(int *cp)
{
	int c=(*cp);
	int i,end=0;
	int left=0, right=0, up=0, down=0;
	int hit0=0, hit1=0, hit2=0, hit3=0, hit4=0, hit5=0;
	SDL_Event event;
	char buf[300];


	while (SDL_PollEvent(&event) > 0)
	{
		if (uib_handle_event(&event)) continue;

		if (event.type == SDL_KEYDOWN)
		{
			uae4all_play_click();
			switch(event.key.keysym.sym)
			{
				case DS_RIGHT1:
				case DS_RIGHT2:
				case DS_RIGHT3:
				case AK_RT: right = 1; break;
				case DS_LEFT1:
				case DS_LEFT2:
				case DS_LEFT3:
				case AK_LF: left = 1; break;
				case DS_UP1:
				case DS_UP2:
				case DS_UP3:
				case AK_UP: up = 1; break;
				case DS_DOWN1:
				case DS_DOWN2:
				case DS_DOWN3:
				case AK_DN: down = 1; break;
				case AK_RET:
				case AK_SPC:
				case DS_START:
				case DS_A: hit0=1; break;
				case DS_R: hit3=1; break;
				case DS_L: hit2=1; break;
				case DS_X: hit5=1; break;
				case DS_Y: hit4=1; break;
				case AK_ESC:
				case DS_B: hit1=1; break;
			}
			if (hit0) {		// A
				if (mode == MODE_LOAD) {
					saveMenu_case = SAVE_MENU_CASE_LOAD_MEM;
					end=1;
				} else 	if (
					!((*files)[c].snaps & (1<<saveMenu_n_savestate)) ||
					text_messagebox(text_str_title, "Overwrite previous state file?", MB_YESNO)==0)
				{
					int i1=(c-offset)*NUM_SS+saveMenu_n_savestate;
					if (thumbs[i1]) {
						SDL_FreeSurface(thumbs[i1]);
						thumbs[i1]=NULL;
					}
					saveMenu_case = SAVE_MENU_CASE_SAVE_MEM;
					end=1;
				}
			}
			else if (hit1)	// B
			{
				saveMenu_case=SAVE_MENU_CASE_CANCEL;
				end=1;
			}
			else if (hit2)	// L
			{
			}
			else if (hit3)	// R
			{
			}
			else if (hit4)	// Y
			{
			}
			else if (hit5)	// X
			{
				if (mode == MODE_LOAD) {
					snprintf(buf,sizeof(buf),"Delete state file #%d for\n%s ?", saveMenu_n_savestate+1, (*files)[c].name);
					if (text_messagebox("Delete State", buf, MB_YESNO)==0) {
						saveMenu_case = SAVE_MENU_CASE_DEL_MEM;
						end=1;
					}
				}
			}
			else if (up || down)
			{
				if (mode == MODE_LOAD) {
					c += up ? -1 : 1;
					if (c < 0) c=nrfiles-1;
					if (c >= nrfiles) c=0;
					saveMenu_n_savestate = saveMenu_n_savestate_real;
				}
			}
			else if (left || right)
			{
				do {
					saveMenu_n_savestate = (saveMenu_n_savestate + (left ? NUM_SS-1 : 1)) % NUM_SS;
				} while (
					mode != MODE_SAVE &&
					(((*files)[c].snaps & (1 << saveMenu_n_savestate)) == 0));
				saveMenu_n_savestate_real = saveMenu_n_savestate;
			}
			else if ((*buf=amiga2ascii(event.key.keysym.sym))!=0) {
				for(i=0;i<nrfiles;++i) {
					if(strncasecmp((*files)[i].name,buf,1)>=0)
						break;
				}
				c=i;
			}
		}
	}

	(*cp)=c;
	return end;
}

static inline void raise_saveMenu()
{
	int i;

	text_draw_background();
	text_flip();
	for(i=0;i<10;i++)
	{
		text_draw_background();
		text_draw_window(192-width*4, 112-height*4+(10-i)*23, (width+2)*8, (height+2)*8, text_str_title);
		text_flip();
	}
}

static inline void unraise_saveMenu()
{
	int i;

	for(i=9;i>=0;i--)
	{
		text_draw_background();
		text_draw_window(192-width*4, 112-height*4+(10-i)*23, (width+2)*8, (height+2)*8, text_str_title);
		text_flip();
	}
	text_draw_background();
	text_flip();
}

static void addFile(const char *file, int nr) {
	int i;
	for (i=0; i<nrfiles; i++) {
		if (strcmp(file, (*files)[i].name) == 0) break;
	}

	if (i==nrfiles) {
		++nrfiles;
		files = (ASFFile (*)[])realloc(files , nrfiles * sizeof(ASFFile));
		(*files)[i].name=strdup((char*)file);
		(*files)[i].snaps=0;
	}
	(*files)[i].snaps |= nr;
}

static int mycmp(const void *a, const void *b) {
	return strcasecmp((*((ASFFile*)a)).name,(*((ASFFile*)b)).name);
}

static void cleanup()
{
	int i;
	// free the file listing
	if (files) {
		for (i=0; i<nrfiles; ++i)
			free((*files)[i].name);
		free(files);
		files = NULL;
	}
	nrfiles=0;
	// free thumbnails
	for (i=0; i < lines * NUM_SS; i++) {
		if (thumbs[i]) {
			SDL_FreeSurface(thumbs[i]);
			thumbs[i]=NULL;
		}
	}
}

int run_menuSave(SaveMode m)
{
	static int c=0;
	int end, i;
	saveMenu_case=-1;
	char buf[300];

	mode = m;

	while(saveMenu_case<0)
	{
		// get list of save states in save state dir
		char *p;
		DIR *dir;
		extern char uae4all_image_file[];
		struct dirent *entry;
		if ((dir = opendir(SAVESTATE_PREFIX)) == NULL) break;
		while ((entry = readdir(dir)) != NULL) {
			p = entry->d_name + strlen(entry->d_name) - 6;
			if (entry->d_type == DT_DIR ||
				p < entry->d_name ||
				strcasecmp(p+2,".asf") != 0 ||
				p[0]!='-' ||
				p[1]<'0' ||
				p[1]>'3')
				continue;
			p[0]=0;

			addFile(entry->d_name, 1 << (p[1]-'0'));
		}
		closedir(dir);
		if (mode == MODE_SAVE)
			addFile(uae4all_image_file[0] ? uae4all_image_file : "null", 0);

		qsort(*files, nrfiles, sizeof(ASFFile), mycmp);

		if (mode == MODE_SAVE) {
			for (i=0;i<nrfiles;++i)
				if (strcmp(uae4all_image_file[0] ? uae4all_image_file : "null", (*files)[i].name) == 0) {
				c=i;
				break;
			}
		}
		text_str_title = (char*)( mode == MODE_LOAD ? text_str_title1 : text_str_title2);

		if (nrfiles <= 0) {
			text_messagebox(text_str_title, "No saved states found", MB_OK);
			saveMenu_case=1;
			break;
		}

		raise_saveMenu();
		end=0;
		while(!end)
		{
			draw_saveMenu(c);
			SDL_Delay(10);
			end=key_saveMenu(&c);
		}
		unraise_saveMenu();
		switch(saveMenu_case)
		{
			case SAVE_MENU_CASE_LOAD_MEM:
			case SAVE_MENU_CASE_SAVE_MEM:
				if (saveMenu_case == SAVE_MENU_CASE_LOAD_MEM) {
					savestate_state = STATE_DORESTORE;
				} else {
					savestate_state =  STATE_DOSAVE;
				}
				snprintf(savestate_filename, 100,
					"%s%s-%d.asf", SAVESTATE_PREFIX, (*files)[c].name, saveMenu_n_savestate);
				saveMenu_case=1;
				break;
			case SAVE_MENU_CASE_DEL_MEM:
				snprintf(buf,sizeof(buf),"%s%s-%d.asf", SAVESTATE_PREFIX, (*files)[c].name, saveMenu_n_savestate);
				unlink(buf);
				snprintf(buf,sizeof(buf),"%s%s-%d.png", SAVESTATE_PREFIX, (*files)[c].name, saveMenu_n_savestate);
				unlink(buf);
				cleanup();
				saveMenu_case=-1; // stay in menu
				break;
			case SAVE_MENU_CASE_EXIT:
			case SAVE_MENU_CASE_CANCEL:	
				saveMenu_case=1;
				break;
			default:
				saveMenu_case=1;
		}
	}
	cleanup();
	return saveMenu_case;
}
#endif
#endif
